wi-fi
DIO-guest
zbst131tPub

github - wasman

статический вложенный класс ???


override - polymorphism at runtime same signature


overload - other signature


java.lang
java.utils


RMI - for clastering apps to connect pcs often use


name.java

name.class - или несколько, если определено несколько классов

изменяемость неизменяемость объектов (mutability)
при сложении String создаются доп объекты - может быть не желательно

pojo не зависит от внешн. библ., минимум функц. - Set, Get - может быть изменяемым или нет

перевод на неизм. объ. - через интерфейс без сеттеров

side effet - изменение объ неявно - bad practice


модификаторы на описание класса - видимость описания класса
final class - не может быть унаследован
final method - не может быть переопределен


static метод - может быть вызван без создания экз. класса

== сравнивает ссылки
пул объектов для сравнения


name.equals(name1);
equals
{ - не нулл ли объект
- сравнение ссылок
- проверка является ли тем же классом
- сравнение полей}

Class Loader - загрузка




1.Контроль ссылок на null при передаче в конструктор - иксепшен?
2. сеттер или геттер не выполняется корректно - как передать статус - иксепшен? или возвр. значение
3. когда несколько классов в одном файле



сначала статич перемен
инстанс
блок инициализации статические
конструкторы цепочка вызовов конструкторов
методы геттеры сеттеры
методы функц
оверрайд методы


мутабельность объекта - передавать интерфеса не сам объект, паттерн билдер

вместо статик переменных лучше сделать отдельный клас

вложенный статически клас можно создать его объект без объекта верхнего класса - часты юзкес

определять массив возле типа данных int[] i = new int[10]

utility class Arrays

проверка usecase



=======lesson 4=======================================================================================


Exceptions

бизнесс методы не ожидают null значения

nullpointer
matherror
stackoverflow
heapoverflow
divbyzero
outofmemmory

- stack
- heap

permgen - c java 1.8 убрали

flags
 - xmx high boundary of memmory
 - xms low

наследники Error - java не гарантирует корректно обработки, часто крах приложения

первы exception - нижни из иерархии

cheked exception

uncheked (runtime exception) - часто не используется


dinamic enum - allows add elements at runtime

singleton - один на данный jvm - enum


unit - минимальный компонент программы - unit тестирование
module - связка юнитов - как взаимодействуют объекты - модульное тестирование

интеграционное тестирование и (end to end) - в связке с другими приложениями - базы данных, сервер ...
интегр. тест обычно не покрывают различные варианты поведения пользователя (разные вх. данные)
этопокрывается юниттест

junit - фреймворк для написания unit tests
сначала продумать что написать - начать с описания теста (behaviour test) testdriving development - как правило

Сегодня все большую популярность приобретает test-driven development(TDD), техника разработки ПО, при которой сначала пишется тест 
на определенный функционал, а затем пишется реализация этого функционала. На практике все, конечно же, не настолько идеально, но в 
результате код не только написан и протестирован, но тесты как бы неявно задают требования к функционалу, а также показывают пример 
использования этого функционала.



scrum, convin - user story - acceptance criteria
usecase 1 - может быть на несколько unit test

ctrl-shift-T junit4 - в том методе который надо тестить
life template для теста


1 test - 1 tested method call - 1 state (input uotput data for 1 state)



А ведь тесты гораздо дороже в написании и поддержке, чем прямо в текущей точке кода понять, что я закладываюсь на 
такие-то свойства аргументов/текущего состояния, и вставить прямо сюда checkArgument/checkState. 
Но написание тестов сейчас является общепринятой практикой. Не наводит ли это вас на мысль, что то, что вы называли 
чесоточным перфекционизмом, на самом деле является просто более зрелым профессионализмом? ;) 


Где обрабатывать искл. ближе к месту возникн. или дальше
конечным полььователем или промежуточным
отдельный класс для обработки исключений...

проверка на null - нету в бизнес логике - есть до этого

есть ли практика получать результат через параметры метода по ссылке, а в return отдавать успешно или не успешно выполнился

тестовые данные для разных usecase - как хранить: отдельный класс на каждый usecase или enum

класс для тестовых данных в папке test где находятся классы junit или тудаже где проект или в др папку

так всетаки один тестовый клас на один test case или на один класс


rt.jar


===============Lesson 5==================================

если есть иксепшин от БД (проблема с данными в бд) то он преобразуется в run-time exception  и на верх
частая практика. Бизнес логика обычно не строится на обработке таких exception

java design elements

- архитектура - язык написания, инфраструктура где выполняется

- дизан - паттерны, стилистика (н-р Spring требует определенную расслоенность приложения)

- имплементация приложиния - кодинг конкретных методов




Делегация - заставить кого- то сделать что-то вместо нас
делегация - прослойка(обертка), может быть многоуровневая
н-р прослойка с профайлингом-метрики(показатели скорости, кол-во памяти),потом прослойка с логированием


Делегат - оболочка -wrapper
вызов структуры классов через интерфейс

dependency injection

serviceDelegate - доп функционал

в IDEA есть возможность переделать наследование в делегацию
пытаться делегировань а не наследовать

resource - от которого зависим - более конкретная реализация- более низкая - депенденси


передача зависимости через конструктор
передача зависимости через сеттер


Buider - сущность для созданя другой сущности

public static class Builder()- вложенный класс
инициализировать не все поля
копирующий конструктор
билдер содержитвсе поля что и его верхний класс


plugin  key promoter

==========lesson 6===========

collections

list
set - уникальные значение - когда надо гарантировать сортированны набор уникальных значени
map - ключ - уникальное значение -
hashmap - если equals то хешкоды равны, коллизия - когда хеши равны но объекты нет
очереди-


vector - потокобезопасный

ArrayList - массив с доп функциональностью
LinkedList - связанный список

Set - структура из HashMap

Queue - ограничение макс и мин количества эл-тов

HashMap - сравнивает хеш нового элта с хранилищем
рекомендуется использовать интерфейс коллекций максимально верхний - при замене н-р ArrayList - Vector


ConcurrentArrayList
ConcurrentMap
....
более продвинутые для многопоточности



backets - array(hash table) - внутри связанные списки -содержит полный элемент - есть loadfactor- на сколько
увеличить бакетс. рехешинг при поступлении нового элемента - не дружит с многопоточностью из-за этого

колво бакетов может меняться динамически - может быть больше и часто так и есть чем кол-во эл-тов


Generics
появились в 1.5
идентификатор типа 1 буква


dimond оператор с 1.7

может быть несколько н-р OrderedPair(...)
nested generic type

Generic methods
можно типизировать любой метод
Анализатор java
Анализатор IDE

Bounded type parameters
parametric тип наследования




???Как видим на рисунке, между интерфейсом и конкретной реализацией коллекции существует несколько абстрактных классов.
Это сделано для того, что бы вынести общий функционал в абстрактный класс, таким образом реализовать повторное использование кода.













